<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Canvas Overlay Demo - WebGL + Canvas 2D</title>
    <style>
        body {
            background: #1a1a1a;
            color: white;
            font-family: sans-serif;
            margin: 20px;
        }
        #canvas-container {
            position: relative;
            width: 800px;
            height: 400px;
            border: 1px solid #444;
        }
        #base-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #2a2a2a;
        }
        #text-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: transparent;
            z-index: 10;
        }
        .info {
            margin: 10px 0;
            padding: 10px;
            background: #333;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>Canvas Overlay Demo</h1>
    <p>Base canvas (black triangles) + Overlay canvas (white rotated text)</p>

    <div class="info">
        <div id="base-size">Base canvas: </div>
        <div id="overlay-size">Overlay canvas: </div>
    </div>

    <div id="canvas-container">
        <canvas id="base-canvas"></canvas>
        <canvas id="text-overlay"></canvas>
    </div>

    <script>
        const container = document.getElementById('canvas-container');
        const baseCanvas = document.getElementById('base-canvas');
        const overlayCanvas = document.getElementById('text-overlay');

        // Set canvas resolution to match display size
        function setupCanvas(canvas) {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            return canvas.getContext('2d');
        }

        const baseCtx = setupCanvas(baseCanvas);
        const overlayCtx = setupCanvas(overlayCanvas);

        document.getElementById('base-size').textContent =
            `Base canvas: ${baseCanvas.width}x${baseCanvas.height}`;
        document.getElementById('overlay-size').textContent =
            `Overlay canvas: ${overlayCanvas.width}x${overlayCanvas.height}`;

        // Draw triangles on base canvas (simulating egui/WebGL)
        function drawTriangle(ctx, points, fillColor, strokeColor) {
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            ctx.lineTo(points[1].x, points[1].y);
            ctx.lineTo(points[2].x, points[2].y);
            ctx.closePath();
            ctx.fillStyle = fillColor;
            ctx.fill();
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // Draw rotated text on overlay canvas
        function drawDimensionText(ctx, x, y, text, angleDegrees) {
            const angleRad = angleDegrees * Math.PI / 180;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angleRad);
            ctx.font = '14px monospace';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 0, 0);
            ctx.restore();
        }

        // Draw dimension along edge
        function drawEdgeDimension(ctx, p1, p2, value) {
            const midX = (p1.x + p2.x) / 2;
            const midY = (p1.y + p2.y) / 2;

            // Calculate angle
            let angle = Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;

            // Flip if upside down
            if (angle > 90 || angle < -90) {
                angle += 180;
            }

            // Perpendicular offset
            const perpX = -(p2.y - p1.y);
            const perpY = (p2.x - p1.x);
            const len = Math.sqrt(perpX * perpX + perpY * perpY);
            const offsetX = (perpX / len) * 15;
            const offsetY = (perpY / len) * 15;

            drawDimensionText(ctx, midX + offsetX, midY + offsetY, value.toFixed(2), angle);
        }

        // Define triangles
        const triangles = [
            {
                points: [
                    { x: 100, y: 300 },
                    { x: 250, y: 100 },
                    { x: 400, y: 300 }
                ],
                sides: [5.0, 4.0, 6.0]
            },
            {
                points: [
                    { x: 400, y: 300 },
                    { x: 550, y: 150 },
                    { x: 700, y: 350 }
                ],
                sides: [4.5, 5.5, 3.5]
            }
        ];

        // Clear and draw base canvas
        baseCtx.fillStyle = '#2a2a2a';
        baseCtx.fillRect(0, 0, baseCanvas.width, baseCanvas.height);

        triangles.forEach((tri, index) => {
            const hue = index * 60 + 200;
            drawTriangle(baseCtx, tri.points, `hsla(${hue}, 50%, 30%, 0.7)`, `hsl(${hue}, 70%, 50%)`);
        });

        // Clear overlay (transparent)
        overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

        // Draw dimensions on overlay
        triangles.forEach(tri => {
            const pts = tri.points;
            // Side A: 0->1
            drawEdgeDimension(overlayCtx, pts[0], pts[1], tri.sides[0]);
            // Side B: 1->2
            drawEdgeDimension(overlayCtx, pts[1], pts[2], tri.sides[1]);
            // Side C: 2->0
            drawEdgeDimension(overlayCtx, pts[2], pts[0], tri.sides[2]);
        });

        // Draw a label to show overlay is working
        overlayCtx.font = '12px sans-serif';
        overlayCtx.fillStyle = 'lime';
        overlayCtx.fillText('â† This text is on the overlay canvas', 10, 20);

        // ========== Alignment Demo ==========
        const alignX = 600;
        const alignY = 50;

        // Draw reference point
        overlayCtx.fillStyle = 'red';
        overlayCtx.beginPath();
        overlayCtx.arc(alignX, alignY, 4, 0, Math.PI * 2);
        overlayCtx.fill();

        // textAlign options: left, center, right, start, end
        // textBaseline options: top, hanging, middle, alphabetic, ideographic, bottom
        const alignments = [
            { align: 'left', baseline: 'top', label: 'left/top' },
            { align: 'center', baseline: 'middle', label: 'center/middle' },
            { align: 'right', baseline: 'bottom', label: 'right/bottom' },
        ];

        alignments.forEach((a, i) => {
            const y = alignY + i * 40;

            // Reference point
            overlayCtx.fillStyle = 'red';
            overlayCtx.beginPath();
            overlayCtx.arc(alignX, y, 3, 0, Math.PI * 2);
            overlayCtx.fill();

            // Text with alignment
            overlayCtx.font = '14px monospace';
            overlayCtx.fillStyle = 'yellow';
            overlayCtx.textAlign = a.align;
            overlayCtx.textBaseline = a.baseline;
            overlayCtx.fillText(`${a.label}: 123.45`, alignX, y);
        });

        // Reset alignment
        overlayCtx.textAlign = 'left';
        overlayCtx.textBaseline = 'alphabetic';

        // DXF-compatible alignment mapping
        overlayCtx.font = '11px sans-serif';
        overlayCtx.fillStyle = '#888';
        overlayCtx.fillText('DXF: HorizontalAlign(0=Left,1=Center,2=Right) + VerticalAlign(0=Baseline,1=Bottom,2=Middle,3=Top)', 10, 390);
    </script>
</body>
</html>
